#include <memory>
#include <sstream>
#include <string>

#include "AC/Core/Dispatch.hpp"
#include "AC/Core/Model.hpp"
#include "AC/Core/Processor.hpp"

#include "ACExport.hpp" // Generated by CMake

namespace ac::core::cpu
{
    namespace arch
    {
        enum
        {
            Begin,
#       ifdef AC_CORE_WITH_EIGEN3
            Eigen3,
#       endif
#       ifdef AC_CORE_WITH_SSE
            SSE,
#       endif
#       ifdef AC_CORE_WITH_AVX
            AVX,
#       endif
#       ifdef AC_CORE_WITH_NEON
            NEON,
#       endif
#       ifdef AC_CORE_WITH_WASM_SIMD128
            WASM_SIMD128,
#       endif
            Generic,
            End
        };
        constexpr const char* NameList[] =
        {
            "Auto",
#       ifdef AC_CORE_WITH_EIGEN3
            "Eigen3",
#       endif
#       ifdef AC_CORE_WITH_SSE
            "SSE",
#       endif
#       ifdef AC_CORE_WITH_AVX
            "AVX",
#       endif
#       ifdef AC_CORE_WITH_NEON
            "NEON",
#       endif
#       ifdef AC_CORE_WITH_WASM_SIMD128
            "WASM_SIMD128",
#       endif
            "Generic"
        };
    }
    void conv3x3_1to8_generic(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_generic(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_residual_8to8_generic(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_generic(const Image& src, Image& dst, const float* kernels);
#ifdef AC_CORE_WITH_EIGEN3
    void conv3x3_1to8_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_residual_8to8_eigen3(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_eigen3(const Image& src, Image& dst, const float* kernels);
#endif
#ifdef AC_CORE_WITH_SSE
    void conv3x3_1to8_sse(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_sse(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_residual_8to8_sse(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_sse(const Image& src, Image& dst, const float* kernels);
#endif
#ifdef AC_CORE_WITH_AVX
    void conv3x3_1to8_avx(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_avx(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_residual_8to8_avx(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_avx(const Image& src, Image& dst, const float* kernels);
#endif
#ifdef AC_CORE_WITH_NEON
    void conv3x3_1to8_neon(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_neon(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_residual_8to8_neon(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_neon(const Image& src, Image& dst, const float* kernels);
#endif
#ifdef AC_CORE_WITH_WASM_SIMD128
    void conv3x3_1to8_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_8to8_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases);
    void conv3x3_residual_8to8_wasm_simd128(const Image& src, Image& dst, const float* kernels, const float* biases);
    void deconv2x2_8to1_wasm_simd128(const Image& src, Image& dst, const float* kernels);
#endif

    class CPUProcessorBase : public Processor
    {
    public:
        CPUProcessorBase(const int arch) noexcept
        {
            idx = (arch > arch::Begin && arch < arch::End) ? arch : []() -> int {
                // x86
#           ifdef AC_CORE_WITH_AVX
                if (dispatch::supportAVX()) return arch::AVX;
#           endif
#           ifdef AC_CORE_WITH_SSE
                if (dispatch::supportSSE()) return arch::SSE;
#           endif
                // arm
#           ifdef AC_CORE_WITH_NEON
                if (dispatch::supportNEON()) return arch::NEON;
#           endif
                // wasm
#           ifdef AC_CORE_WITH_WASM_SIMD128
                return arch::WASM_SIMD128;
#           endif
                // generic
#           ifdef AC_CORE_WITH_EIGEN3
                return arch::Eigen3;
#           else
                return arch::Generic;
#           endif
                }();

            switch (idx)
            {
#       ifdef AC_CORE_WITH_EIGEN3
            case arch::Eigen3:
                conv3x3_1to8 = conv3x3_1to8_eigen3;
                conv3x3_8to8 = conv3x3_8to8_eigen3;
                conv3x3_residual_8to8 = conv3x3_residual_8to8_eigen3;
                deconv2x2_8to1 = deconv2x2_8to1_eigen3;
                break;
#       endif
#       ifdef AC_CORE_WITH_SSE
            case arch::SSE:
                conv3x3_1to8 = conv3x3_1to8_sse;
                conv3x3_8to8 = conv3x3_8to8_sse;
                conv3x3_residual_8to8 = conv3x3_residual_8to8_sse;
                deconv2x2_8to1 = deconv2x2_8to1_sse;
                break;
#       endif
#       ifdef AC_CORE_WITH_AVX
            case arch::AVX:
                conv3x3_1to8 = conv3x3_1to8_avx;
                conv3x3_8to8 = conv3x3_8to8_avx;
                conv3x3_residual_8to8 = conv3x3_residual_8to8_avx;
                deconv2x2_8to1 = deconv2x2_8to1_avx;
                break;
#       endif
#       ifdef AC_CORE_WITH_NEON
            case arch::NEON:
                conv3x3_1to8 = conv3x3_1to8_neon;
                conv3x3_8to8 = conv3x3_8to8_neon;
                conv3x3_residual_8to8 = conv3x3_residual_8to8_neon;
                deconv2x2_8to1 = deconv2x2_8to1_neon;
                break;
#       endif
#       ifdef AC_CORE_WITH_WASM_SIMD128
            case arch::WASM_SIMD128:
                conv3x3_1to8 = conv3x3_1to8_wasm_simd128;
                conv3x3_8to8 = conv3x3_8to8_wasm_simd128;
                conv3x3_residual_8to8 = conv3x3_residual_8to8_wasm_simd128;
                deconv2x2_8to1 = deconv2x2_8to1_wasm_simd128;
                break;
#       endif
            default:
                conv3x3_1to8 = conv3x3_1to8_generic;
                conv3x3_8to8 = conv3x3_8to8_generic;
                conv3x3_residual_8to8 = conv3x3_residual_8to8_generic;
                deconv2x2_8to1 = deconv2x2_8to1_generic;
                break;
            }
        }
        ~CPUProcessorBase() noexcept override = default;

        const char* name() const noexcept override
        {
            return arch::NameList[idx];
        }
    protected:
        void (*conv3x3_1to8)(const Image& src, Image& dst, const float* kernels, const float* biases);
        void (*conv3x3_8to8)(const Image& src, Image& dst, const float* kernels, const float* biases);
        void (*conv3x3_residual_8to8)(const Image& src, Image& dst, const float* kernels, const float* biases);
        void (*deconv2x2_8to1)(const Image& src, Image& dst, const float* kernels);
    };

    template<typename Model>
    class CPUProcessorSeqCNN : public CPUProcessorBase
    {
    public:
        CPUProcessorSeqCNN(const int arch, const Model& model) noexcept : CPUProcessorBase(arch)
        {
            kernels = model.kptr<float>();
            biases = model.bptr<float>();
        }
        ~CPUProcessorSeqCNN() noexcept override = default;

    protected:
        const float* kernels;
        const float* biases;
    };

    template<typename Model>
    class CPUProcessor;
}

template<>
class ac::core::cpu::CPUProcessor<ac::core::model::ACNet> : public ac::core::cpu::CPUProcessorSeqCNN<ac::core::model::ACNet>
{
public:
    CPUProcessor(int arch, const model::ACNet& model) noexcept;
    ~CPUProcessor() noexcept override;

private:
    void process(const Image& src, Image& dst) override;
};

ac::core::cpu::CPUProcessor<ac::core::model::ACNet>::CPUProcessor(const int arch, const model::ACNet& model) noexcept : CPUProcessorSeqCNN(arch, model) {}
ac::core::cpu::CPUProcessor<ac::core::model::ACNet>::~CPUProcessor() noexcept = default;

void ac::core::cpu::CPUProcessor<ac::core::model::ACNet>::process(const Image& src, Image& dst)
{
    Image tmp1{ src.width(), src.height(), 8, ac::core::Image::Float32 };
    Image tmp2{ src.width(), src.height(), 8, ac::core::Image::Float32 };
    conv3x3_1to8(src, tmp1, kernels + model::ACNet::kernelOffset[0], biases + model::ACNet::baisOffset[0]);
    conv3x3_8to8(tmp1, tmp2, kernels + model::ACNet::kernelOffset[1], biases + model::ACNet::baisOffset[1]);
    conv3x3_8to8(tmp2, tmp1, kernels + model::ACNet::kernelOffset[2], biases + model::ACNet::baisOffset[2]);
    conv3x3_8to8(tmp1, tmp2, kernels + model::ACNet::kernelOffset[3], biases + model::ACNet::baisOffset[3]);
    conv3x3_8to8(tmp2, tmp1, kernels + model::ACNet::kernelOffset[4], biases + model::ACNet::baisOffset[4]);
    conv3x3_8to8(tmp1, tmp2, kernels + model::ACNet::kernelOffset[5], biases + model::ACNet::baisOffset[5]);
    conv3x3_8to8(tmp2, tmp1, kernels + model::ACNet::kernelOffset[6], biases + model::ACNet::baisOffset[6]);
    conv3x3_8to8(tmp1, tmp2, kernels + model::ACNet::kernelOffset[7], biases + model::ACNet::baisOffset[7]);
    conv3x3_8to8(tmp2, tmp1, kernels + model::ACNet::kernelOffset[8], biases + model::ACNet::baisOffset[8]);
    deconv2x2_8to1(tmp1, dst, kernels + model::ACNet::kernelOffset[9]);
}

template<>
AC_EXPORT std::shared_ptr<ac::core::Processor> ac::core::Processor::create<ac::core::Processor::CPU ,ac::core::model::ACNet>(const int idx, const model::ACNet& model)
{
    return std::make_shared<cpu::CPUProcessor<model::ACNet>>(idx, model);
}


template<>
class ac::core::cpu::CPUProcessor<ac::core::model::ARNet> : public ac::core::cpu::CPUProcessorSeqCNN<ac::core::model::ARNet>
{
public:
    CPUProcessor(int arch, const model::ARNet& model) noexcept;
    ~CPUProcessor() noexcept override;

private:
    void process(const Image& src, Image& dst) override;
};

ac::core::cpu::CPUProcessor<ac::core::model::ARNet>::CPUProcessor(const int arch, const model::ARNet& model) noexcept : CPUProcessorSeqCNN(arch, model) {}
ac::core::cpu::CPUProcessor<ac::core::model::ARNet>::~CPUProcessor() noexcept = default;

void ac::core::cpu::CPUProcessor<ac::core::model::ARNet>::process(const Image& src, Image& dst)
{
    Image tmp1{ src.width(), src.height(), 8, ac::core::Image::Float32 };
    Image tmp2{ src.width(), src.height(), 8, ac::core::Image::Float32 };
    conv3x3_1to8(src, tmp1, kernels + model::ARNet::kernelOffset[0], biases + model::ARNet::baisOffset[0]);
    conv3x3_8to8(tmp1, tmp2, kernels + model::ARNet::kernelOffset[1], biases + model::ARNet::baisOffset[1]);
    conv3x3_residual_8to8(tmp2, tmp1, kernels + model::ARNet::kernelOffset[2], biases + model::ARNet::baisOffset[2]);
    conv3x3_8to8(tmp1, tmp2, kernels + model::ARNet::kernelOffset[3], biases + model::ARNet::baisOffset[3]);
    conv3x3_residual_8to8(tmp2, tmp1, kernels + model::ARNet::kernelOffset[4], biases + model::ARNet::baisOffset[4]);
    conv3x3_8to8(tmp1, tmp2, kernels + model::ARNet::kernelOffset[5], biases + model::ARNet::baisOffset[5]);
    conv3x3_residual_8to8(tmp2, tmp1, kernels + model::ARNet::kernelOffset[6], biases + model::ARNet::baisOffset[6]);
    conv3x3_8to8(tmp1, tmp2, kernels + model::ARNet::kernelOffset[7], biases + model::ARNet::baisOffset[7]);
    conv3x3_residual_8to8(tmp2, tmp1, kernels + model::ARNet::kernelOffset[8], biases + model::ARNet::baisOffset[8]);
    deconv2x2_8to1(tmp1, dst, kernels + model::ARNet::kernelOffset[9]);
}

template<>
AC_EXPORT std::shared_ptr<ac::core::Processor> ac::core::Processor::create<ac::core::Processor::CPU, ac::core::model::ARNet>(const int idx, const model::ARNet& model)
{
    return std::make_shared<cpu::CPUProcessor<model::ARNet>>(idx, model);
}


template<>
AC_EXPORT const char* ac::core::Processor::info<ac::core::Processor::CPU>()
{
    static auto infoBuffer = []() -> std::string {
        std::ostringstream buffer{ "CPU:\n", std::ios_base::ate };
        for (int i = cpu::arch::Begin; i < cpu::arch::End; i++)
        {
            buffer << "  [" << i << "] " << cpu::arch::NameList[i] << '\n';
        }
        return buffer.str();
        }();
    return infoBuffer.c_str();
}
