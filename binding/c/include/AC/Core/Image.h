#ifndef AC_BINDING_C_CORE_IMAGE_H
#define AC_BINDING_C_CORE_IMAGE_H

#include <stdint.h>
#include <stddef.h>

#include "CACExport.h" // Generated by CMake

#ifdef __cplusplus
#   define CAC_API extern "C" CAC_EXPORT
#else
#   define CAC_API CAC_EXPORT
#endif

enum ac_image_element_type
{
    AC_IMAGE_UINT8   = 0 << 8 | 1,
    AC_IMAGE_UINT16  = 0 << 8 | 2,
    AC_IMAGE_FLOAT32 = 2 << 8 | 4
};

enum ac_imread_modes
{
    AC_IMREAD_UNCHANGED = 0,
    AC_IMREAD_GRAYSCALE = 1,
    AC_IMREAD_COLOR     = 3,
    AC_IMREAD_RGB       = 3,
    AC_IMREAD_RGBA      = 4,
};

enum ac_resize_modes
{
    AC_RESIZE_POINT,
    AC_RESIZE_CATMULL_ROM,        // b = 0, c = 0.5 or a = -0.5
    AC_RESIZE_MITCHELL_NETRAVALI, // b = 1/3, c = 1/3
    AC_RESIZE_BICUBIC_0_60,       // b = 0, c = 0.6 or a = -0.6
    AC_RESIZE_BICUBIC_0_75,       // b = 0, c = 0.75 or a = -0.75
    AC_RESIZE_BICUBIC_0_100,      // b = 0, c = 1 or a = -1
    AC_RESIZE_BICUBIC_20_50,      // b = 0.2, c = 0.5
    AC_RESIZE_SOFTCUBIC50,        // b = 0.5, c = 0.5
    AC_RESIZE_SOFTCUBIC75,        // b = 0.75, c = 0.25
    AC_RESIZE_SOFTCUBIC100,       // b = 1, c = 0
    AC_RESIZE_LANCZOS2,
    AC_RESIZE_LANCZOS3,
    AC_RESIZE_LANCZOS4,
    AC_RESIZE_SPLINE16,
    AC_RESIZE_SPLINE36,
    AC_RESIZE_SPLINE64,
    AC_RESIZE_BILINEAR,
};

typedef struct ac_image
{
    int width;
    int height;
    int channels;
    int stride;
    int element_type;
    void* ptr;
    struct ac_image_handle* hptr;
} ac_image;

CAC_API int ac_image_ref(const ac_image* src, ac_image* dst);
CAC_API void ac_image_unref(ac_image* image);
CAC_API int ac_image_create(ac_image* image);
CAC_API int ac_image_map(ac_image* image);
CAC_API int ac_image_from(ac_image* image, const void* data);
CAC_API int ac_image_clone(const ac_image* src, ac_image* dst);
CAC_API int ac_image_to(const ac_image* image, void* data, int stride);

#ifndef AC_CORE_DISABLE_IMAGE_IO
CAC_API int ac_imread(const char* filename, int mode, ac_image* image);
CAC_API int ac_imwrite(const char* filename, const ac_image* image);
#endif

CAC_API int ac_resize(const ac_image* src, ac_image* dst, double fx, double fy, int mode);
CAC_API int ac_rgb2yuv(const ac_image* rgb, ac_image* yuv);
CAC_API int ac_rgba2yuva(const ac_image* rgba, ac_image* yuva);
CAC_API int ac_yuv2rgb(const ac_image* yuv, ac_image* rgb);
CAC_API int ac_yuva2rgba(const ac_image* yuva, ac_image* rgba);

static int ac_image_size(const ac_image* image)
{
    return image->height * image->stride;
}
static int ac_image_element_size(const ac_image* image)
{
    return image->element_type & 0xff;
}
static int ac_image_pixel_size(const ac_image* image)
{
    return image->channels * ac_image_element_size(image);
}
static uint8_t* ac_image_data(const ac_image* image)
{
    return (uint8_t*)image->ptr;
}
static uint8_t* ac_image_line(const ac_image* image, int y)
{
    return ac_image_data(image) + image->stride * y;
}
static uint8_t* ac_image_pixel(const ac_image* image, int x, int y)
{
    return ac_image_line(image, y) + x * ac_image_pixel_size(image);
}
static int ac_image_empty(const ac_image* image)
{
    return image->ptr == NULL;
}
static int ac_image_is_uint(const ac_image* image)
{
    return (image->element_type >> 8) == 0;
}
static int ac_image_is_int(const ac_image* image)
{
    return (image->element_type >> 8) == 1;
}
static int ac_image_is_float(const ac_image* image)
{
    return (image->element_type >> 8) == 2;
}
static int ac_image_same(const ac_image* a, const ac_image* b)
{
    return a->ptr == b->ptr;
}

#endif
